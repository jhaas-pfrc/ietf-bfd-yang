<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="no"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<rfc category="std" docName="draft-zheng-bfd-yang-02.txt" ipr="trust200902">
    <front>
        <title abbrev="BFD Yang">Yang Data Model for Bidirectional Forwarding
    Detection (BFD)</title>
        <author fullname="Lianshu Zheng" initials="L." role="editor" surname="Zheng">
            <organization>Huawei Technologies</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>China</country>
                </postal>
                <email>vero.zheng@huawei.com</email>
            </address>
        </author>
        <author fullname="Reshad Rahman" initials="R." role="editor" surname="Rahman">
            <organization>Cisco Systems</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>Canada</country>
                </postal>
                <email>rrahman@cisco.com</email>
            </address>
        </author>
        <author fullname="Santosh Pallagatti" initials="S." surname="Pallagatti">
            <organization>Juniper Networks</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>India</country>
                </postal>
                <email>santoshpk@juniper.net</email>
            </address>
        </author>
        <author fullname="Mahesh Jethanandani" initials="M." surname="Jethanandani">
            <organization>Ciena Corporation</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country/>
                </postal>
                <email>mjethanandani@gmail.com</email>
            </address>
        </author>
        <date day="25" month="May" year="2015"/>
        <abstract>
            <t>This document defines a YANG data model that can be used to configure
      and manage Bidirectional Forwarding Detection (BFD).</t>
        </abstract>
        <note title="Requirements Language">

            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
        </note>
    </front>
    <middle>
        <section title="Introduction">
            <t>YANG <xref
                    target="RFC6020"/> is a data definition language that was
      introduced to define the contents of a conceptual data store that allows
      networked devices to be managed using NETCONF <xref
                    target="RFC6241"/>. 
      YANG is proving relevant beyond its initial confines, as bindings to other 
      interfaces (e.g RESTCONF <xref target="I-D.ietf-netconf-restconf"/>) and encodings other than XML (e.g JSON) are being
      defined. Furthermore, YANG data models can be used as the basis of implementation
      for other interfaces, such as CLI and programmatic APIs.</t>

            <t>This document defines a YANG data model that can be used to configure
      and manage Bidirectional Forwarding Detection (BFD)<xref target="RFC5880"/>. 
      BFD is a network protocol which is used for liveness detection of arbitrary paths between systems. Some examples of different types of paths over which we have BFD:</t>

            <t>1) Two systems directly connected via IP. This is known as BFD over single-hop IP <xref target="RFC5881"/>
            </t>
            <t>2) Two systems connected via multiple hops <xref target="RFC5883"/>
            </t>

            <t>3) Two systems connected via MPLS Label Switched Paths (LSPs) <xref target="RFC5884"/>
            </t>

            <t>4) Two systems connected via a Link Aggregation Group (LAG) interface <xref target="RFC7130"/>
            </t>

            <t>BFD typically does not operate on its own. Various control protocols, aka BFD clients, use the services provided by BFD for their own operation <xref target="RFC5882"/>. The obvious candidates which use BFD are those which do not have Hellos to detect failures (e.g. static routes) and routing protocols whose Hellos do not suport sub-second failure detection, e.g OSPF and IS-IS.
		</t>
            <section title="Contributors">
                <t/>
            </section>
        </section>
        <section title="Design of the Data Model  ">
            <t/>
            <section title="Design of configuration model">
                <t/>

                <t>The configuration model consists mainly of the parameters specified in <xref target="RFC5880"/>. Some examples are desired minimum transmit interval, required minimum receive interval, detection multiplier etc </t>
                <t>Some implementations have BFD configuration under the BFD client, e.g. BFD configuration is under routing applications such as OSPF, IS-IS, BGP etc. Other implementations have BFD configuration centralized, i.e outside the multiple BFD clients. In the sections below we address both approaches.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
                <section title="Centralized BFD configuration">
                    <t>The BFD data model consists of configuring BFD sessions of different types (e.g. single-hop IP, multi-hop IP etc). Since the different session types have different keys we have a list per session type, but we use a grouping to share the common  configuration data between the different session types.</t>
                    <t/>
                    <section anchor="COMMON-BFD-CFG" title="Common BFD configuration">

                        <t> The common BFD session configuration items are put in a grouping to be used in multiple places, these items are:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="local-multiplier">

                                    <vspace/>This is the detection time multiplier as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="desired-min-tx-interval">

                                    <vspace/>This is the Desired Min TX Interval as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="required-min-rx-interval">

                                    <vspace/>This is the Required Min RX Interval as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="demand-enabled">

                                    <vspace/>Set to True to enable demand mode as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="enable-authentication">
                                    <vspace/>Set to True to enable BFD authentication.</t>
                                <t hangText="authentication-algorithm">
                                    <vspace/>Authentication algorithm to use (if enabled).</t>
                                <t hangText="key-chain-name">
                                    <vspace/>Key-chain to be used for authentication (if enabled).</t>
                            </list>
                        </t>
                    </section>
                    <section anchor="SH-CFG" title="Single-hop IP">

                        <t>We have a list for BFD sessions over single-hop IP. The key consists of:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="interface">
                                    <vspace/>This is the interface on which the BFD packets for this session are transmitted and received. Examples of an interface are physical media, virtual circuit, tunnel etc.</t>
                                <t hangText="destination address">

                                    <vspace/>Address belonging to the peer system as per <xref target="RFC5881"/>
                                </t>
                            </list>
                        </t>
                        <t>The common configuration data in <xref
                                target="COMMON-BFD-CFG"/> is used for single-hop IP. On top of that common data, we also need configuration data for echo:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="desired-min-echo-tx-interval">

                                    <vspace/>This is the minimum interval that the local system would like to use when transmitting BFD echo packets. If 0 the echo function as defined in <xref target="RFC5880"/> is disabled.</t>
                                <t hangText="required-min-echo-rx-interval">

                                    <vspace/>The is the Required Min Echo RX Interval as defined in <xref target="RFC5880"/>.</t>
                            </list>
                        </t>
                    </section>
                    <section title="Multi-hop IP">

                        <t>We have a list for BFD sessions over multi-hop IP. The key consists of:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="source address">

                                    <vspace/>Address belonging to the local system as per <xref target="RFC5883"/>
                                </t>
                                <t hangText="destination address">

                                    <vspace/>Address belonging to the remote system as per <xref target="RFC5883"/>
                                </t>
                                <t hangText="VRF name">
                                    <vspace/>VRF in which the BFD multi-hop session is running</t>
                            </list>
                        </t>
                        <t>The common configuration data in <xref
                                target="COMMON-BFD-CFG"/> is used for multi-hop IP.On top of that common data, we also need TTL:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="ttl">
                                    <vspace/>TTL of outgoing BFD control packets.</t>
                            </list>
                        </t>
                    </section>
                    <section title="MPLS LSP">
                        <t>TBD</t>
                    </section>
                    <section title="Link Aggregation Group">
                        <t>TBD</t>
                    </section>
                    <section anchor="IF-CFG" title="Per-interface configuration">

                        <t>For implementations which have multiplier and intervals configured under the BFD clients we still need a central location to configure authentication, demand mode etc. This can be done by configuring the following parameters per interface:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="Common parameters">

                                    <vspace/>The common BFD parameters listed in <xref target="COMMON-BFD-CFG"/>
                                </t>
                                <t hangText="Echo parameters">

                                    <vspace/>The echo parameters listed in <xref target="SH-CFG"/>
                                </t>
                            </list>
                        </t>
                    </section>
                </section>
                <section title="Configuration in BFD clients">
                    <t> When BFD is configured in BFD clients, it is highly desirable to have BFD configuration consistency between those  clients. In this approach we have a grouping for BFD configuration which applications can import in their YANG module:</t>
                    <t>- This provides consistency since the same grouping is being used in all applications making use of BFD</t>
                    <t>- Since not all implementations of those BFD clients have support for BFD, we must use if-feature in the respective YANG modules</t>
                    <t>An application importing the BFD configuration grouping could do so in a hierarchical manner if it has multiple levels at which BFD configuration can be applied. In a subsequent section we provide an example of how a BFD client would use the grouping in such a way.</t>
                    <t> The configuration items are:
          <list
                            hangIndent="8" style="hanging">
                            <t hangText="enabled">
                                <vspace/>Set to True to enable BFD.</t>
                            <t hangText="local-multiplier">

                                <vspace/>This the detection time multiplier as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="desired-min-tx-interval">

                                <vspace/>This the Desired Min TX Interval as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="required-min-rx-interval">

                                <vspace/>This the Required Min RX Interval as defined in <xref target="RFC5880"/>.</t>
                        </list>
                    </t>
                </section>
            </section>
            <section title="Design of operational model">
                <t>The operational model contains both the overall statistics of BFD sessions running on the device and the per session operational statistics. Since BFD is used for liveness detection of arbitrary paths, there is no uniform key to identify a BFD session. e.g. a BFD single-hop IP session is uniquely identified by the combination of destination IP address and interface whereas a multihop IP session is uniquely identified by the combination of source IP address, destination IP address and VRF.  For this reason, for per session operational statistics, we do not have a single list with different type BFD sessions.  Instead we have a container in which we have multiple lists, where each list corresponds to one specific path type for BFD.  For example we have one operational list for BFD single-hop IP, another list for BFD multi-hop IP etc.  In each list, mainly three categories of operational items are shown.  The fundamental information of a BFD session such as the local discriminator, remote discriminator and the capability of supporting demand detect mode are shown in the first category.  A second category includes a BFD session running information, e.g. the FSM the device in and diagnostic code received.  Another example is the actual transmit interval between the control packets, which may be different from the desired minimum transmit interval configured, is shown in this category.  Similar examples are actual received interval between the control packets and the actual transmit interval between the echo packets.  The third category contains the detailed statistics of this session, e.g. when the session went to up/down, how long it has been since the session is up/down.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
            </section>
            <section title="Notifications">
                <t>This YANG model defines a list of notifications to inform clients of BFD with important events detected during the protocol operation. Pair of local and remote discriminator identifies a BFD session on local system. Notification also give more important details about BFD sessions e.g. new state, time in previous state, VRF and reason for BFD session state changed.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
            </section>
            <section title="RPC Operations">
                <t>TBD</t>
            </section>
            <section title="BFD Configuration Data Hierarchy">
                <section title="Centralized BFD configuration">
                    <t>The following is the centralized configuration data hierarchy: </t>
                    <t>We have a container which contains a list for each session type</t>
                    <t>We have per-interface configuration</t>
                    <figure align="left">
                        <preamble/>
                        <artwork align="left">
module: ietf-bfd
   +--rw bfd
      +--rw bfd-cfg
      |  +--rw bfd-session-cfg {bfd-centralized-session-config}?
      |  |  +--rw session-ip-sh* [interface dest-addr]
      |  |  |  +--rw interface                        if:interface-ref
      |  |  |  +--rw dest-addr                        inet:ip-address
      |  |  |  +--rw admin-down?                      boolean
      |  |  |  +--rw local-multiplier?                multiplier
      |  |  |  +--rw desired-min-tx-interval          uint32
      |  |  |  +--rw required-min-rx-interval         uint32
      |  |  |  +--rw demand-enabled?                  boolean
      |  |  |  +--rw enable-authentication?           boolean
      |  |  |  +--rw authentication-parms {bfd-authentication}?
      |  |  |  |  +--rw key-chain-name?   string
      |  |  |  |  +--rw algorithm?        bfd-auth-algorithm
      |  |  |  +--rw desired-min-echo-tx-interval?    uint32
      |  |  |  +--rw required-min-echo-rx-interval?   uint32
      |  |  +--rw session-ip-mh* [vrf-name source-addr dest-addr]
      |  |     +--rw vrf-name                    vrfName
      |  |     +--rw source-addr                 inet:ip-address
      |  |     +--rw dest-addr                   inet:ip-address
      |  |     +--rw admin-down?                 boolean
      |  |     +--rw local-multiplier?           multiplier
      |  |     +--rw desired-min-tx-interval     uint32
      |  |     +--rw required-min-rx-interval    uint32
      |  |     +--rw demand-enabled?             boolean
      |  |     +--rw enable-authentication?      boolean
      |  |     +--rw authentication-parms {bfd-authentication}?
      |  |     |  +--rw key-chain-name?   string
      |  |     |  +--rw algorithm?        bfd-auth-algorithm
      |  |     +--rw tx-ttl?                     TTL
      |  |     +--rw rx-ttl                      TTL
      |  +--rw bfd-interface-cfg* [interface] {bfd-interface-config}?
      |     +--rw interface                        if:interface-ref
      |     +--rw local-multiplier?                multiplier
      |     +--rw desired-min-tx-interval          uint32
      |     +--rw required-min-rx-interval         uint32
      |     +--rw demand-enabled?                  boolean
      |     +--rw enable-authentication?           boolean
      |     +--rw authentication-parms {bfd-authentication}?
      |     |  +--rw key-chain-name?   string
      |     |  +--rw algorithm?        bfd-auth-algorithm
      |     +--rw desired-min-echo-tx-interval?    uint32
      |     +--rw required-min-echo-rx-interval?   uint32
          </artwork>
                    </figure>
                </section>
                <section title="Configuration in BFD clients">
                    <t>The following is the configuration data hierarchy for a hypothetical BFD client called bfd-routing-app, the BFD configuration is supported conditionally via use of if-feature. </t>
                    <t>We have a list of areas and in each area we have a list of interfaces. The BFD configuration grouping is used in a hierarchical fashion, it can be applied in "area" and "interface": </t>
                    <t>- If BFD configuration is applied under an interface, that configuration takes precedence over any BFD configuration (if any) at the area level</t>
                    <t>- If BFD configuration is applied under an "area" and none of the interfaces in that area has BFD configuration, then all interfaces belong to the "area" in question inherit the BFD configuration for the area in question.</t>
                    <t>- If the BFD client implementation supports "interface all", then all the interfaces belonging to that area will inherit the BFD configuration under "interface all". Along with this if there are specific interface configuration then specific interface will override the "interface all" parameters.</t>
                    <figure align="left">
                        <preamble/>
                        <artwork align="left">
module: bfd-routing-app
   +--rw area* [area-id]
      +--rw area-id      uint32
      +--rw bfd-cfg
      |  +--rw enabled?                    boolean
      |  +--rw local-multiplier?           multiplier
      |  +--rw desired-min-tx-interval     uint32
      |  +--rw required-min-rx-interval    uint32
      +--rw interface* [interface]
         +--rw interface    if:interface-ref
         +--rw bfd-cfg
            +--rw enabled?                    boolean
            +--rw local-multiplier?           multiplier
            +--rw desired-min-tx-interval     uint32
            +--rw required-min-rx-interval    uint32


          </artwork>
                    </figure>
                </section>
            </section>
            <section title="Operational Data Hierarchy">
                <t>The complete data hierarchy of BFD YANG operational model is presented below.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
module: ietf-bfd
   +--rw bfd
      +--ro bfd-oper
         +--ro bfd-session-statistics
         |  +--ro ip-sh-session-num?   uint32
         |  +--ro ip-mh-session-num?   uint32
         |  +--ro total-session-num?   uint32
         |  +--ro session-up-num?      uint32
         |  +--ro sess-down-num?       uint32
         +--ro bfd-session-lists
            +--ro session-ip-sh* [interface dest-addr]
            |  +--ro interface               if:interface-ref
            |  +--ro dest-addr               inet:ip-address
            |  +--ro sesssion-type?          enumeration
            |  +--ro local-discriminator?    discriminator
            |  +--ro remote-discriminator?   discriminator
            |  +--ro remote-multiplier?      multiplier
            |  +--ro out-interface?          if:interface-ref
            |  +--ro demand-capability?      boolean
            |  +--ro session-running*
            |  |  +--ro local-state?               state
            |  |  +--ro remote-state?              state
            |  |  +--ro local-diagnostic?          diagnostic
            |  |  +--ro remote-diagnostic?         diagnostic
            |  |  +--ro detect-Mode?               enumeration
            |  |  +--ro actual-tx-interval?        uint32
            |  |  +--ro actual-rx-interval?        uint32
            |  |  +--ro actual-echo-tx-interval?   uint32
            |  |  +--ro detect-time?               uint32
            |  +--ro sesssion-statistics*
            |     +--ro create-time?         yang:date-and-time
            |     +--ro last-down-time?      yang:date-and-time
            |     +--ro last-up-time?        yang:date-and-time
            |     +--ro receive-pkt?         uint64
            |     +--ro send-pkt?            uint64
            |     +--ro down-count?          uint32
            |     +--ro receive-bad-pkt?     uint64
            |     +--ro send-failed-pkt?     uint64
            |     +--ro short-break-count?   uint32
            +--ro session-ip-mh* [vrfName source-addr dest-addr]
               +--ro vrfName                 vrfName
               +--ro source-addr             inet:ip-address
               +--ro dest-addr               inet:ip-address
               +--ro ttl?                    TTL
               +--ro sesssion-type?          enumeration
               +--ro local-discriminator?    discriminator
               +--ro remote-discriminator?   discriminator
               +--ro remote-multiplier?      multiplier
               +--ro out-interface?          if:interface-ref
               +--ro demand-capability?      boolean
               +--ro session-running*
               |  +--ro local-state?               state
               |  +--ro remote-state?              state
               |  +--ro local-diagnostic?          diagnostic
               |  +--ro remote-diagnostic?         diagnostic
               |  +--ro detect-Mode?               enumeration
               |  +--ro actual-tx-interval?        uint32
               |  +--ro actual-rx-interval?        uint32
               |  +--ro actual-echo-tx-interval?   uint32
               |  +--ro detect-time?               uint32
               +--ro sesssion-statistics*
                  +--ro create-time?         yang:date-and-time
                  +--ro last-down-time?      yang:date-and-time
                  +--ro last-up-time?        yang:date-and-time
                  +--ro receive-pkt?         uint64
                  +--ro send-pkt?            uint64
                  +--ro down-count?          uint32
                  +--ro receive-bad-pkt?     uint64
                  +--ro send-failed-pkt?     uint64
                  +--ro short-break-count?   uint32            
        </artwork>
                </figure>
            </section>
            <section title="Notifications">
                <t>The BFD YANG data model defines notifications for BFD session state changes.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
module: ietf-bfd
notifications:
   +---n bfd-singlehop-notification    
   |  +--ro local-discr?              discriminator
   |  +--ro remote-discr?             discriminator
   |  +--ro new-state?                state
   |  +--ro state-change-reason?      string
   |  +--ro time-in-previous-state?   string
   |  +--ro dest-addr?                inet:ip-address
   |  +--ro interface?                if:interface-ref
   |  +--ro echo-enabled?             boolean
   +---n bfd-multihop-notification     
      +--ro local-discr?              discriminator
      +--ro remote-discr?             discriminator
      +--ro new-state?                state
      +--ro state-change-reason?      string
      +--ro time-in-previous-state?   string
      +--ro dest-addr?                inet:ip-address
      +--ro vrf-name?                 vrfName
      +--ro source-addr?              inet:ip-address
        </artwork>
                </figure>
            </section>
            <section title="Examples">
                <t/>
            </section>
            <section title="Interaction with other YANG modules">
                <t>TBD.</t>
            </section>
            <section title="BFD Yang Module">
                <figure align="left">
                    <preamble/>
                    <artwork align="left"><![CDATA[
<CODE BEGINS> file "ietf-bfd@2015-05-25.yang"
module ietf-bfd {
  namespace "urn:ietf:params:xml:ns:yang:ietf-bfd";
  // replace with IANA namespace when assigned
  prefix "bfd";
   
  import ietf-interfaces {
    prefix "if";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  import ietf-yang-types {
    prefix "yang";
  }

  organization "IETF BFD Working Group";

  contact 
    "WG Web:   <http://tools.ietf.org/wg/bfd>
     WG List:  <rtg-bfd@ietf.org>
     WG Chair: Jeff Haas
     WG Chair: Nobo Akiya
     Editor:   Lianshu Zheng and Reshad Rahman";

  description 
    "This module contains the YANG definition for BFD parameters as
     per RFC5880, RFC5881 and RFC5883";

  revision 2015-05-25 {
    description "Initial revision.";
    reference "RFC XXXX: A YANG data model for BFD";
  }

  typedef discriminator {
    type uint32 {
      range 1..4294967295;
    }
    description "BFD discriminator";
  }

  typedef diagnostic {    
    type enumeration {
      enum none {
        value 0;
        description "None";
      }
      enum controlExpiry {
        value 1;
        description "Control timer expiry";
      }
      enum echoFailed {
        value 2;
        description "Echo failure";
      }
      enum nborDown {
        value 3;
        description "Neighbor down";
      }
      enum fwdingReset {
        value 4;
        description "Forwarding reset";
      }
      enum pathDown {
        value 5;
        description "Path down";
      }
      enum concPathDown {
        value 6;
        description "Concatenated path down";
      }
      enum adminDown {
        value 7;
        description "Admin down";
      }
      enum reverseConcPathDown {
        value 8;
        description "Reverse concatenated path down";
      }
    }
    description "BFD diagnostic";
  }

  typedef state {    
    type enumeration {
      enum adminDown {
        value 0;
        description "admindown";
      }
      enum down {
        value 1;
        description "down";
      }
      enum init {
        value 2;
        description "init";
      }
      enum up {
        value 3;
        description "up";
      }
    }
    description "BFD state";
  }

  typedef multiplier {
    type uint8 {
      range 1..255;
    }
    description "Multiplier";
  }

  typedef TTL {
    type uint8 {
      range 1..255;
    }
    description "Time To Live";
  }

  typedef bfd-auth-algorithm {
    type enumeration {
      enum simple-password {
        description
          "Simple password";
      }
      
      enum keyed-md5 {
        description
          "Keyed message Digest 5";
      }
      
      enum meticulous-keyed-md5 {
        description
          "Meticulous keyed message Digest 5";
      }
                                               
      enum keyed-sha-1 {
        description
          "Keyed secure hash algorithm (SHA1) ";
      }
                                               
      enum meticulous-keyed-sha-1 {
        description
          "Meticulous keyed secure hash algorithm (SHA1) ";
      }
    }
    description "Authentication algorithm";
  }

  typedef vrfName {
    type string;
    description "VRF Name";
  }        

  feature bfd-centralized-session-config {
    description "BFD session centralized config supported";
  }
  feature bfd-interface-config {
    description "BFD per-interface config supported";
  }
  feature bfd-authentication {
    description "BFD authentication supported";
  }

  grouping bfd-grouping-common-cfg-parms {
    description "BFD grouping for common config parameters";
    
    leaf local-multiplier {
      type multiplier;
      default 3;
      description "Local multiplier";
    }

    leaf desired-min-tx-interval {
      type uint32;
      units microseconds;
      mandatory true;
      description 
        "Desired minimum transmit interval of control packets";
    }

    leaf required-min-rx-interval {
      type uint32;
      units microseconds;
      mandatory true;
      description 
        "Required minimum receive interval of control packets";
    }

    leaf demand-enabled {
      type boolean;
      default false;
      description "To enbale demand mode";
    }

    leaf enable-authentication {
      type boolean;
      default false;
      description 
        "If set, the Authentication Section is present and the 
         session is to be authenticated (see RFC5880 section 6.7 
         for details).";
    }

    container authentication-parms {
      if-feature bfd-authentication;
      description "Parameters for authentication";
      leaf key-chain-name {
        type string;
        must "../algorithm" {
          error-message
            "May not be configured without algorithm";
          description "Requires algorithm";
        }
        description
          "Key chain name";
      }
      leaf algorithm {
        type bfd-auth-algorithm;
        must "../key-chain" {
          error-message
            "May not be configured without key-chain";
          description "Requires key-chain";
        }
        description "Authentication algorithm to be used";
      }
    }
  }

  grouping bfd-grouping-echo-cfg-parms {
    description "BFD grouping for echo config parameters";
    leaf desired-min-echo-tx-interval {
      type uint32;
      units microseconds;
      default 0;
      description "Desired minumum transmit interval for echo";
    }

    leaf required-min-echo-rx-interval {
      type uint32;
      units microseconds;
      default 0;
      description "Required minimum receive interval for echo";
    }
  }

  grouping bfd-client-base-cfg-parms {
    description 
      "BFD grouping for base config parameters which could be used 
       by a protocol which is a client of BFD";
    
    container bfd-cfg {
      description "BFD configuration";
      leaf enabled {
        type boolean;
        default false;
        description "True if BFD is enabled";
      }

      leaf local-multiplier {
        type multiplier;
        default 3;
        description "Multiplier transmitted by local system";
      }

      leaf desired-min-tx-interval {
        type uint32;
        units microseconds;
        mandatory true;
        description 
          "Desired minimum transmit interval of control packets";
      }

      leaf required-min-rx-interval {
        type uint32;
        units microseconds;
        mandatory true;
        description 
          "Required minimum receive interval of control packets";
      }
    }
  }

  grouping bfd-client-full-cfg-parms {
    description 
      "BFD grouping for complete config parameters which could be
       used by a protocol which is a client of BFD.";
    
    container bfd-cfg {
      description "BFD configuration";
      leaf enabled {
        type boolean;
        default false;
        description "True if BFD is enabled";
      }

      uses bfd-grouping-common-cfg-parms;

      uses bfd-grouping-echo-cfg-parms;
    }
  }

  grouping bfd-all-session {
    description "BFD session operational information";
    leaf sesssion-type {
      type enumeration {
        enum ip-single-hop {
          value "0";
          description "IP single hop";
        }
        enum ip-multi-hop {
          value "1";
          description "IP multi hop";
        }
      }
      description 
        "BFD session type, this indicates the path type that BFD is 
        running on";
    }
    leaf local-discriminator {
      type discriminator;
      description "Local discriminator";
    }
    leaf remote-discriminator {
      type discriminator;
      description "Remote discriminator";
    }
    leaf remote-multiplier {
      type multiplier;
      description "Remote multiplier";
    }
    leaf out-interface {
      type if:interface-ref;
      description "Outgoing physical interface name";
    }                
    leaf demand-capability{
      type boolean;
      description "Local demand mode capability";
    }                

    list session-running {
      description "BFD session running information";
      leaf local-state {
        type state;
        description "Local state";
      }
      leaf remote-state {
        type state;
        description "Remote state";
      } 
      leaf local-diagnostic {
        type diagnostic;
        description "Local diagnostic";
      }
      leaf remote-diagnostic {
        type diagnostic;
        description "Remote diagnostic";
      }
      leaf detect-Mode {
        type enumeration {
          enum async-with-echo {
            value "0";
            description "Async with echo";
          }
          enum async-without-echo {
            value "1";
            description "Async without echo";
          }
          enum demand-with-echo {
            value "2";
            description "Demand with echo";
          }
          enum demand-without-echo {
            value "3";
            description "Demand without echo";
          }
        }
        description "Detect mode";
      }
      leaf actual-tx-interval {
        type uint32;
        units microseconds;
        description "Actual transmit interval";
      }
      leaf actual-rx-interval {
        type uint32;
        units microseconds;
        description "Actual receive interval";
      }
      leaf actual-echo-tx-interval {
        type uint32;
        units microseconds;
        description "Actual echo transmit interval";
      }
      leaf detect-time {
        type uint32;
        units microseconds;
        description "Detect time";
      }
    }

    list sesssion-statistics {
      description "BFD session statistics";

      leaf create-time {
        type yang:date-and-time;
        description 
          "Time and date when session was created";
      }
      leaf last-down-time {
        type yang:date-and-time;
        description 
          "Time and date of last time the session went down";
      }
      leaf last-up-time {
        type yang:date-and-time;
        description 
          "Time and date of last time the session went up";
      }
      leaf receive-pkt {
        type uint64;
        description "Received Packet Count";
      }
      leaf send-pkt {
        type uint64;
        description "Sent Packet Count";
      }
      leaf down-count {
        type uint32;
        description "Session Down Count";
      }
      leaf receive-bad-pkt {
        type uint64;
        description "Received bad packet count";
      }
      leaf send-failed-pkt {
        type uint64;
        description "Packet Failed to Send Count";
      }
      leaf short-break-count {
        type uint32;
        default "0";
        description "Shortbreak count";
      }
    }
  }

  container bfd {
    description "BFD top-level container";
    container bfd-cfg {
      description "BFD configuration";
      container bfd-session-cfg {
        if-feature bfd-centralized-session-config;
        description "BFD session configuration";
        list session-ip-sh {
          key "interface dest-addr";
          description "List of IP single-hop sessions";
          leaf interface {
            type if:interface-ref;
            description 
              "Interface on which the IP single-hop session is 
             running.";
          }
          leaf dest-addr {
            type inet:ip-address;
            description
              "IP address of the peer";
          }
          leaf admin-down {
            type boolean;
            default false;
            description 
              "Is the BFD session administratively down";
          }
          uses bfd-grouping-common-cfg-parms;

          uses bfd-grouping-echo-cfg-parms;
        }

        list session-ip-mh {
          key "vrf-name source-addr dest-addr";
          description "List of IP multi-hop sessions";

          leaf vrf-name {
            type vrfName;
            description "Routing instance";
          }
          leaf source-addr {
            type inet:ip-address;
            description 
              "Local IP address";
          }
          leaf dest-addr {
            type inet:ip-address;
            description
              "IP address of the peer";
          }
          leaf admin-down {
            type boolean;
            default false;
            description 
              "Is the BFD session administratively down";
          }
          uses bfd-grouping-common-cfg-parms;

          leaf tx-ttl {
            type TTL;
            default 255;
            description "TTL of outgoing BFD control packets";
          }
          leaf rx-ttl {
            type TTL;
            mandatory true;
            description 
              "Minimum allowed TTL value for incoming BFD control 
            packets";
          }
        }
      }

      list bfd-interface-cfg {
        if-feature bfd-interface-config;
        key interface;

        description "Per-interface BFD configuration";
        leaf interface {
          type if:interface-ref;
          description "Interface";

        }
        uses bfd-grouping-common-cfg-parms;

        uses bfd-grouping-echo-cfg-parms;   

      }
    }

    container bfd-oper {
      config "false";      
      description "BFD operational container";
      container bfd-session-statistics {      
        description "BFD session counters";
        leaf ip-sh-session-num {
          type uint32;
          description "IP single hop session number";
        }
        leaf ip-mh-session-num {
          type uint32;
          description "IP multi hop session Number";
        }
        leaf total-session-num {
          type uint32;
          description "Total session number";
        }
        leaf session-up-num {
          type uint32;
          description "Session up number";
        }
        leaf sess-down-num {
          type uint32;
          description "Session down number";
        }
      }
    
      container bfd-session-lists {
        description "Contains multiple session lists, one per type";
        list session-ip-sh {
          key "interface dest-addr";
          description "BFD IP single-hop sessions";
          leaf interface {
            type if:interface-ref;
            description 
              "Interface on which the BFD session is running.";
          }
          leaf dest-addr {
            type inet:ip-address;
            description "BFD peer address";
          }

          uses bfd-all-session;
        }

        list session-ip-mh {
          key "vrfName source-addr dest-addr";
          description "BFD IP multi-hop sessions";
          leaf vrfName {
            type vrfName;
            description "VRF";
          }
          leaf source-addr {
            type inet:ip-address;
            description "BFD source address";
          }
          leaf dest-addr {
            type inet:ip-address;
            description "BFD peer address";
          }
          leaf ttl {
            type TTL;
            description "TTL of session";
          }
          uses bfd-all-session;
        }
      }
    }
  }
  
  grouping bfd-notification-params {
    description
      "This group describes common params that will be send 
        as part of BFD notification";
        
    leaf local-discr {
      type discriminator;
      description "BFD local discriminator";
    }
        
    leaf remote-discr {
      type discriminator;
      description "BFD remote discriminator";
    }
        
    leaf new-state {
      type state;
      description "Current BFD state";
    }
        
    leaf state-change-reason {
      type string;
      description "BFD state change reason";
    }
        
    leaf time-in-previous-state {
      type string;
      description 
        "How long the BFD session was in the previous state";
    }
        
    leaf dest-addr {
      type inet:ip-address;
      description "BFD peer address";
    }
  }
    
  notification bfd-singlehop-notification {
    description 
      "Notitification for BFD single-hop session state change";

    uses bfd-notification-params;
        
    leaf interface {
      type if:interface-ref;
      description "Interface to which this BFD session belongs to";
    }
        
    leaf echo-enabled {
      type boolean;
      description "Was echo enabled for BFD";
    }
  }
    
    
  notification bfd-multihop-notification {
    description 
      "Notitification for BFD multi-hop session state change";

    uses bfd-notification-params;
        
    leaf vrf-name {
      type vrfName;
      description "Routing instance";
    }
        
    leaf source-addr {
      type inet:ip-address;
      description "BFD local address";
    }
  }
}
<CODE ENDS>
        ]]></artwork>
                </figure>
            </section>
            <section title="BFD Client Example Configuration Yang Module">
                <figure align="left">
                    <preamble/>
                    <artwork align="left">

module example-bfd-routing-app {
   namespace "urn:cisco:params:xml:ns:yang:bfdroutingapp";
   prefix bfd-routing-app;

   import ietf-bfd {
     prefix "bfd";
   }

   import ietf-interfaces {
     prefix "if";
   }

   organization
     "ACME";
   contact
     "acme@acme.com";

   description
     "Testing BFD grouping (simulating a routing application)";

   revision 2015-02-14 {
     description
       "Initial revision.";
   }

   feature routing-app-bfd {
     description "BFD configuration under routing-app";
   }

   list area {
     description
       "Specify a routing area.";

     key "area-id";

     leaf area-id {
       type uint32;
     }

     uses bfd:bfd-client-base-cfg-parms {
       if-feature routing-app-bfd;
     }

     list interface {
       key "interface";
       leaf interface {
         type if:interface-ref;
       }
       uses bfd:bfd-client-base-cfg-parms {
         if-feature routing-app-bfd;
       }
     }

   }
}
        </artwork>
                </figure>
            </section>
            <section title="Security Considerations">
                <t>The YANG module defined in this memo is designed to be accessed via the NETCONF protocol [RFC6241]. The lowest NETCONF layer is the secure transport layer and the mandatory to implement secure transport is SSH [RFC6242]. The NETCONF access control model [RFC6536] provides the means to restrict access for particular NETCONF users to a pre-configured subset of all available NETCONF protocol operations and content.</t>
                <t>The YANG module has writeable data nodes which can be used for creation of BFD sessions and modification of BFD session parameters. The system should "police" creation of BFD sessions to prevent new sessions from causing existing BFD sessions to fail. For BFD session modification, the BFD protocol has mechanisms in place which allow for in service modification. </t>
            </section>
            <section title="IANA Considerations">
                <t>The IANA is requested to as assign a new new namespace URI from the
      IETF XML registry.</t>
                <t>URI:TBD</t>
            </section>
            <section title="Acknowledgements">
                <t>We would also like to thank Nobo Akiya and Jeff Haas for their
      encouragement on this work.</t>
            </section>
        </section>
    </middle>
    <back>
        <references title="Normative References"><?rfc include="reference.RFC.2119"?><?rfc include='reference.RFC.6020'?><?rfc include='reference.RFC.6241'?><?rfc include='reference.RFC.5880'?><?rfc include='reference.RFC.5881'?><?rfc include='reference.RFC.5882'?><?rfc include='reference.RFC.5883'?><?rfc include='reference.RFC.5884'?><?rfc include='reference.RFC.7130'?>
        </references>
        <references title="Informative References"><?rfc include="reference.I-D.ietf-netconf-restconf"?>
        </references>
        <section title="Change log">
           <t>RFC Editor: Remove this section upon publication as an RFC.</t>
           <section title="Changes between versions -01 and -02">
              <t>
              <list style="symbols">
                 <t>Fixed errors and warnings from "pyang --ietf"</t>
                 <t>Added appendix for "Change log"</t>
              </list>
              </t>
           </section>
           <section title="Changes between versions -00 and -01">
              <t>In the YANG module section:
                 <list style="symbols">
                    <t>Added missing filename</t>
                    <t>Added missing CODE ENDS</t>
                 </list>
              </t>
           </section>
        </section>
    </back>
</rfc>
